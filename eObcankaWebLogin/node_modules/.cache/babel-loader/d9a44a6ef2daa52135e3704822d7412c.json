{"ast":null,"code":"import _regeneratorRuntime from \"/home/roman/testws/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/roman/testws/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/roman/testws/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/roman/testws/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport * as eccrypto from 'eccrypto'; // todo\n\nvar webSocketUrl = 'ws://192.168.51.154:8080/websocket/msg'; // automatical request\n\nvar responseObject = {\n  cmd: 'handshake',\n  msg: {\n    birthNumber: '120493904239048',\n    documentNumber: '271498327498',\n    publicKey: '23oiroi2joi23jrio23j'\n  },\n  signature: '99r8329r8j2398fj93f2j983f2j'\n};\n\nvar WebID =\n/*#__PURE__*/\nfunction () {\n  function WebID() {\n    _classCallCheck(this, WebID);\n\n    this.webSocket = new WebSocket(webSocketUrl);\n    this.setListeners();\n    this.handshakeCmd = false;\n    this.handshakeCallback = null;\n    this.handshakeData = null;\n    this.dataCmd = null;\n    this.message = null;\n    this.signature = null;\n  }\n\n  _createClass(WebID, [{\n    key: \"login\",\n    value: function login(cb) {\n      if (this.handshakeData !== null) {\n        cb(null, this.handshakeData.message, this.handshakeData.signature);\n      } else {\n        if (this.webSocket.readyState === 1) {\n          this.handshakeCmd = true;\n          this.webSocket.send({\n            cmd: 'handshake',\n            msg: {}\n          });\n          this.handshakeCallback = cb;\n        } else {\n          cb({\n            msg: 'connection error',\n            readyState: this.webSocket.readyState\n          }, null, null);\n        }\n      }\n    }\n  }, {\n    key: \"handshake\",\n    value: function () {\n      var _handshake = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(message, signature) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.handshakeCmd) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.validateMessage(message, signature);\n\n              case 3:\n                this.handshakeCallback(null, message, signature);\n                _context.next = 8;\n                break;\n\n              case 6:\n                this.validateMessage(message, signature);\n                this.handshakeData = {\n                  message: message,\n                  signature: signature\n                };\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function handshake(_x, _x2) {\n        return _handshake.apply(this, arguments);\n      }\n\n      return handshake;\n    }()\n  }, {\n    key: \"getData\",\n    value: function getData(messaage, signature) {// todo\n    }\n  }, {\n    key: \"setListeners\",\n    value: function setListeners() {\n      var _this = this;\n\n      this.webSocket.onmessage = function (event) {\n        var data = JSON.parse(event.data);\n\n        switch (data.cmd) {\n          case 'handshake':\n            _this.handshake(data.msg, data.signature);\n\n            break;\n\n          case 'data':\n            _this.getData(data.msg, data.signature);\n\n            break;\n\n          default:\n            throw new Error('unknown cmd');\n        }\n      };\n    }\n  }, {\n    key: \"validateMessage\",\n    value: function validateMessage(message, signature) {\n      var publicKey = message.publicKey;\n      var signedMessage = JSON.stringify(message);\n      var bufferedMessage = Buffer.from(signedMessage, 'utf8');\n      eccrypto.verify(publicKey, bufferedMessage, signature).then(function () {\n        return Promise.resolve(true);\n      }).catch(function () {\n        return Promise.reject(false);\n      });\n    }\n  }]);\n\n  return WebID;\n}();\n\nexport default WebID;\n/*\nasync function login() {\n  try {\n    const data = await fetch(`${baseUrl}/login`);\n    await eccrypto.verify(data.publicKey, data.message, data.signature);\n    return Promise.resolve(data.message);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nfunction data() {\n  fetch(`${baseUrl}/data`).then((data) => {\n    eccrypto\n    console.log(data);\n  }).catch((err) => {\n    console.log(err);\n  });\n}\n\nlogin();\n\n*/","map":{"version":3,"sources":["/home/roman/testws/src/components/webId.js"],"names":["eccrypto","webSocketUrl","responseObject","cmd","msg","birthNumber","documentNumber","publicKey","signature","WebID","webSocket","WebSocket","setListeners","handshakeCmd","handshakeCallback","handshakeData","dataCmd","message","cb","readyState","send","validateMessage","messaage","onmessage","event","data","JSON","parse","handshake","getData","Error","signedMessage","stringify","bufferedMessage","Buffer","from","verify","then","Promise","resolve","catch","reject"],"mappings":"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","sourcesContent":["import * as eccrypto from 'eccrypto'; // todo\nconst webSocketUrl = 'ws://192.168.51.154:8080/websocket/msg';\n\n// automatical request\nconst responseObject = {\n  cmd: 'handshake',\n  msg: {\n    birthNumber: '120493904239048',\n    documentNumber: '271498327498',\n    publicKey: '23oiroi2joi23jrio23j'\n  },\n  signature: '99r8329r8j2398fj93f2j983f2j'\n}\n\nclass WebID {\n\n  webSocket;\n  handshakeCmd;\n  handshakeCallback;\n  handshakeData;\n  message;\n  signature;\n  dataCmd;\n\n  constructor() {\n    this.webSocket = new WebSocket(webSocketUrl);\n    this.setListeners();\n    this.handshakeCmd = false;\n    this.handshakeCallback = null;\n    this.handshakeData = null;\n    this.dataCmd = null;\n    this.message = null;\n    this.signature = null;\n  }\n\n  login(cb) {\n    if (this.handshakeData !== null) {\n      cb(null, this.handshakeData.message, this.handshakeData.signature);\n    } else {\n      if (this.webSocket.readyState === 1) {\n        this.handshakeCmd = true;\n        this.webSocket.send({ cmd: 'handshake', msg: {} });\n        this.handshakeCallback = cb;\n      } else {\n        cb({ msg: 'connection error', readyState: this.webSocket.readyState }, null, null);\n      }\n\n    }\n  }\n\n  async handshake(message, signature) {\n    if (this.handshakeCmd) {\n      await this.validateMessage(message, signature);\n      this.handshakeCallback(null, message, signature);\n    } else {\n      this.validateMessage(message, signature);\n      this.handshakeData = { message, signature };\n    }\n  }\n\n  getData(messaage, signature) {\n    // todo\n  }\n\n  setListeners() {\n    this.webSocket.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      switch (data.cmd) {\n        case 'handshake':\n          this.handshake(data.msg, data.signature);\n          break;\n        case 'data':\n          this.getData(data.msg, data.signature);\n          break;\n        default:\n          throw new Error('unknown cmd');\n      }\n    }\n  }\n\n  validateMessage(message, signature) {\n    const publicKey = message.publicKey;\n    const signedMessage = JSON.stringify(message);\n    const bufferedMessage = Buffer.from(signedMessage, 'utf8');\n    eccrypto.verify(publicKey, bufferedMessage, signature).then(() => {\n      return Promise.resolve(true);\n    }).catch(() => {\n      return Promise.reject(false);\n    });\n  }\n\n}\n\nexport default WebID;\n\n/*\nasync function login() {\n  try {\n    const data = await fetch(`${baseUrl}/login`);\n    await eccrypto.verify(data.publicKey, data.message, data.signature);\n    return Promise.resolve(data.message);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\n\nfunction data() {\n  fetch(`${baseUrl}/data`).then((data) => {\n    eccrypto\n    console.log(data);\n  }).catch((err) => {\n    console.log(err);\n  });\n}\n\nlogin();\n\n*/"]},"metadata":{},"sourceType":"module"}